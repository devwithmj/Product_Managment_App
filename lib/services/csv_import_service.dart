import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:uuid/uuid.dart';
import '../models/product.dart';
import 'database_service.dart';

/// Result of a CSV import operation
class CsvImportResult {
  final int totalRows;
  final int updatedProducts;
  final int createdProducts;
  final int errorRows;
  final List<String> errors;
  final List<Product> autoGeneratedProducts;

  CsvImportResult({
    required this.totalRows,
    required this.updatedProducts,
    required this.createdProducts,
    required this.errorRows,
    required this.errors,
    required this.autoGeneratedProducts,
  });

  int get successfulRows => updatedProducts + createdProducts;
  bool get hasErrors => errorRows > 0;

  @override
  String toString() {
    return 'CsvImportResult(total: $totalRows, updated: $updatedProducts, '
        'created: $createdProducts, errors: $errorRows)';
  }
}

/// Data model for a single CSV row
class CsvRowData {
  final String price;
  final String barcode;
  final String name;
  final int rowNumber;

  CsvRowData({
    required this.price,
    required this.barcode,
    required this.name,
    required this.rowNumber,
  });

  double? get parsedPrice {
    try {
      // Remove any currency symbols and whitespace
      final cleanPrice = price.replaceAll(RegExp(r'[^\d\.]'), '');
      return double.tryParse(cleanPrice);
    } catch (e) {
      return null;
    }
  }

  bool get isValid {
    return barcode.isNotEmpty && name.isNotEmpty && parsedPrice != null;
  }

  @override
  String toString() {
    return 'CsvRowData(row: $rowNumber, price: $price, barcode: $barcode, name: $name)';
  }
}

/// Service for importing product data from CSV files
class CsvImportService {
  static final CsvImportService _instance = CsvImportService._internal();
  factory CsvImportService() => _instance;
  CsvImportService._internal();

  final DatabaseService _databaseService = DatabaseService();

  /// Import products from a CSV file
  ///
  /// Expected CSV format: barcode,price,name,date
  /// - barcode: Unique identifier for the product (leading zeros will be removed)
  /// - price: Numeric value (can include currency symbols)
  /// - name: Product name (will be used for both English and Persian if not existing)
  /// - date: Optional date field (will be ignored)
  Future<CsvImportResult> importFromCsv(File csvFile) async {
    if (kDebugMode) {
      print('Starting CSV import from: ${csvFile.path}');
    }

    List<String> errors = [];
    List<Product> autoGeneratedProducts = [];
    int totalRows = 0;
    int updatedProducts = 0;
    int createdProducts = 0;
    int errorRows = 0;

    try {
      // Read the CSV file
      final csvContent = await csvFile.readAsString();
      final lines = csvContent.split('\n');

      // Skip empty file
      if (lines.isEmpty) {
        errors.add('CSV file is empty');
        return CsvImportResult(
          totalRows: 0,
          updatedProducts: 0,
          createdProducts: 0,
          errorRows: 1,
          errors: errors,
          autoGeneratedProducts: [],
        );
      }

      // Check if first line is header (contains column names like "f01", "f30", etc.)
      int startRow = 0;

      if (lines.isNotEmpty) {
        final firstLine = lines[0].toLowerCase();
        if (firstLine.contains('f01') ||
            firstLine.contains('f30') ||
            firstLine.contains('f02') ||
            (firstLine.contains('price') &&
                firstLine.contains('barcode') &&
                firstLine.contains('name'))) {
          startRow = 1;
          if (kDebugMode) {
            print('Detected CSV header row');
          }
        }
      } // Process each data row
      for (int i = startRow; i < lines.length; i++) {
        final line = lines[i].trim();
        if (line.isEmpty) continue; // Skip empty lines

        totalRows++;
        final rowNumber = i + 1;

        try {
          final rowData = _parseCsvRow(line, rowNumber);

          if (!rowData.isValid) {
            errors.add('Row $rowNumber: Invalid data - ${rowData.toString()}');
            errorRows++;
            continue;
          }

          // Process the row
          final result = await _processRow(rowData);

          if (result.$1) {
            // Success
            if (result.$2) {
              // Was created
              createdProducts++;
              if (result.$3 != null) {
                autoGeneratedProducts.add(result.$3!);
              }
            } else {
              // Was updated
              updatedProducts++;
            }
          } else {
            // Error
            errors.add('Row $rowNumber: ${result.$4}');
            errorRows++;
          }
        } catch (e) {
          errors.add('Row $rowNumber: Error processing row - $e');
          errorRows++;
          if (kDebugMode) {
            print('Error processing row $rowNumber: $e');
          }
        }
      }

      if (kDebugMode) {
        print(
          'CSV import completed: $totalRows total, $updatedProducts updated, '
          '$createdProducts created, $errorRows errors',
        );
      }

      return CsvImportResult(
        totalRows: totalRows,
        updatedProducts: updatedProducts,
        createdProducts: createdProducts,
        errorRows: errorRows,
        errors: errors,
        autoGeneratedProducts: autoGeneratedProducts,
      );
    } catch (e) {
      if (kDebugMode) {
        print('Fatal error during CSV import: $e');
      }

      errors.add('Failed to read CSV file: $e');
      return CsvImportResult(
        totalRows: totalRows,
        updatedProducts: updatedProducts,
        createdProducts: createdProducts,
        errorRows: errorRows + 1,
        errors: errors,
        autoGeneratedProducts: autoGeneratedProducts,
      );
    }
  }

  /// Parse a single CSV row into CsvRowData
  CsvRowData _parseCsvRow(String line, int rowNumber) {
    // Simple CSV parsing - split by comma and handle quoted values
    final parts = _splitCsvLine(line);

    if (parts.length < 3) {
      throw Exception(
        'Expected at least 3 columns (barcode,price,name), got ${parts.length}',
      );
    }

    // Extract barcode and remove leading zeros and whitespace
    String barcode = parts[0].trim();
    barcode = _removeLeadingZeros(barcode);

    return CsvRowData(
      barcode: barcode,
      price: parts[1].trim(),
      name: parts[2].trim(),
      rowNumber: rowNumber,
    );
  }

  /// Remove leading zeros from barcode
  String _removeLeadingZeros(String barcode) {
    // Remove quotes and extra whitespace
    barcode = barcode.replaceAll('"', '').trim();

    // Remove leading zeros but keep at least one digit
    barcode = barcode.replaceFirst(RegExp(r'^0+'), '');

    // If all digits were zeros, keep one zero
    if (barcode.isEmpty) {
      barcode = '0';
    }

    return barcode;
  }

  /// Split CSV line handling quoted values
  List<String> _splitCsvLine(String line) {
    List<String> result = [];
    bool inQuotes = false;
    String currentField = '';

    for (int i = 0; i < line.length; i++) {
      final char = line[i];

      if (char == '"') {
        inQuotes = !inQuotes;
      } else if (char == ',' && !inQuotes) {
        result.add(currentField.trim());
        currentField = '';
      } else {
        currentField += char;
      }
    }

    // Add the last field
    result.add(currentField.trim());

    // Remove quotes from fields
    return result.map((field) => field.replaceAll('"', '')).toList();
  }

  /// Process a single row of data
  /// Returns (success, wasCreated, product, errorMessage)
  Future<(bool, bool, Product?, String)> _processRow(CsvRowData rowData) async {
    try {
      // Check if product with this barcode already exists
      final existingProduct = await _databaseService.getProductByBarcode(
        rowData.barcode,
      );

      if (existingProduct != null) {
        // Update existing product price
        final updatedProduct = existingProduct.copyWith(
          price: rowData.parsedPrice!,
          updatedAt: DateTime.now(),
        );

        await _databaseService.saveProduct(
          updatedProduct,
          oldProduct: existingProduct,
        );

        if (kDebugMode) {
          print(
            'Updated product ${existingProduct.nameEn} (${rowData.barcode}) price: '
            '${existingProduct.price} -> ${rowData.parsedPrice}',
          );
        }

        return (true, false, updatedProduct, '');
      } else {
        // Create new product with default values
        final newProduct = Product(
          id: const Uuid().v4(),
          nameEn: rowData.name,
          nameFa: rowData.name, // Use same name for Persian
          brandEn: 'Auto Import', // Default brand
          brandFa: 'واردات خودکار', // Default Persian brand
          sizeValue: '', // Default empty size
          unitType: UnitType.piece, // Default unit type
          price: rowData.parsedPrice!,
          priceUpdated: true, // Mark as price updated since it's new
          storeLocation: StoreLocation.both, // Default location
          barcode: rowData.barcode,
          isAutoGenerated: true, // Mark as auto-generated
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );

        await _databaseService.saveProduct(newProduct);

        if (kDebugMode) {
          print(
            'Created new product ${newProduct.nameEn} (${rowData.barcode}) '
            'with price ${rowData.parsedPrice}',
          );
        }

        return (true, true, newProduct, '');
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error processing row ${rowData.rowNumber}: $e');
      }
      return (false, false, null, e.toString());
    }
  }

  /// Validate CSV file format before importing
  Future<(bool, String, int)> validateCsvFile(File csvFile) async {
    try {
      final csvContent = await csvFile.readAsString();
      final lines =
          csvContent
              .split('\n')
              .where((line) => line.trim().isNotEmpty)
              .toList();

      if (lines.isEmpty) {
        return (false, 'CSV file is empty', 0);
      }

      // Check if first line might be header
      int dataRows = lines.length;
      int testRowIndex = 0;

      if (lines.isNotEmpty) {
        final firstLine = lines[0].toLowerCase();
        if (firstLine.contains('f01') ||
            firstLine.contains('f30') ||
            firstLine.contains('f02') ||
            (firstLine.contains('price') &&
                firstLine.contains('barcode') &&
                firstLine.contains('name'))) {
          dataRows = lines.length - 1;
          testRowIndex = 1;
        }
      }

      // Validate at least one data row
      if (dataRows == 0) {
        return (false, 'No data rows found in CSV', 0);
      }

      // Check format of first data row
      final testRow = lines[testRowIndex];
      final parts = _splitCsvLine(testRow);

      if (parts.length < 3) {
        return (
          false,
          'Invalid CSV format. Expected columns: barcode,price,name',
          0,
        );
      }

      // Try to parse price from second column (index 1)
      final testPrice = parts[1].trim().replaceAll(RegExp(r'[^\d\.]'), '');
      if (double.tryParse(testPrice) == null) {
        return (false, 'Invalid price format in first data row', 0);
      }

      return (true, 'CSV file is valid', dataRows);
    } catch (e) {
      return (false, 'Error reading CSV file: $e', 0);
    }
  }
}
